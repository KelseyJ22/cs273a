average_based_classifier.py computes the average score for each of the labels in the data from the Vista Enhancer Browser and returns that value as the prediction. It reports 0 or 1 for positive (an enhancer) or negative (not an enhancer) purely based on whether there were more shared k-mers of length 4, 5, 6, 7, or 8 in positive- or negative-labeled sequences in the training data.

The binaries wigToBigWig and bigWigAverageOverBed are downloaded from the UCSC Genome Browser and used as "wigToBigWig input.wig chrom.sizes myBigWig.bw" (with input.wig as zipped or unzipped wig file and chrom.sizes computed by the fetchChromSizes utility) and "./bigWigAverageOverBed in.bw in.bed out.tab", respectively. TODO figure out fetchChromSizes and bigWigAverageOverBed

Wig, BigWig, .tab files Explained
---------------------------------
Wig files are essentially lists of 1 or 0 (present or not present) for some descriptor/element/etc at some location. It can also be other numbers if the wig file encodes more than present/not present for one thing, for example if it recorded presence of a bunch of different things, but we only have 0 or 1. The corresponding bigWig file contains the same data (nothing gained or lost) but in a newer, more efficient data presentation format. We don't really care about the format for our purposes.

The .tab file is where it gets interesting and useful. It is created by checking the average amount of present markers in some region specified in the .bed file. The scheme is name (of .bed entry), size (all entries), covered (where some marker was found in that region), sum (total number of present markers), mean_covered (average across locations where present), mean_all (average across all regions). For our purposes we likely want to use mean_covered as our feature -- it answers the question "how often is this epigenomic marker associated with this region?" and we can pair it with the labels in the fasta-like file we get from the Vista Enhancer Browser.